# HTTP

## HTTP概述

HTTP是一种用作获取诸如HTML文档这类资源的**协议**（protocol）。
它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方——通常是浏览器——发起的。一个完整网页文档是由获取到的不同文档组件——像是文本、布局描述、图片、视频、脚本等——重新构建出来的。

**协议**是定义了数据如何在计算机内和之间进行交换的规则的系统。设备之间通信要求设备接受正在交换的数据的格式。定义格式的一组规则称之为协议。

![一个网页文档是多种不同资源的组合](https://raw.githubusercontent.com/just-createone/images/master/fetching_a_page.png)



客户端与服务端之间通过交换一个个独立的消息（而非数据流）进行通信。由客户端——通常是个浏览器——发出的消息被称作*请求*（request），由服务端发出的应答消息被称作*响应*（response）。

![HTTP 作为应用层协议，处于 TCP（传输层）和 IP（网络层）之上，表示层之下](https://raw.githubusercontent.com/just-createone/images/master/http-layers.png)

### 基于HTTP的组件系统

* HTTP 是一个客户端—服务器协议：请求由一个实体，即用户代理（user agent），或是一个可以代表它的代理方（proxy）发出。大多数情况下，这个用户代理都是一个网页浏览器，不过它也可能是任何东西，比如一个爬取网页来充实、维护搜索引擎索引的机器爬虫。
  * 每个请求都会被发送到一个服务端，它会处理这个请求并提供一个称作*响应*的回复。
    在客户端与服务端之间，有许许多多被称为**代理的实体**，履行不同的作用，例如充当**网关**和**缓存**。
    ![客户端与服务器间的链条](https://raw.githubusercontent.com/just-createone/images/master/client-server-chain.png)
    * **缓存**：
      临时存储HTTP响应的组件，只要符合要求就可用于后续的HTTP请求。
    * **网关**：
      网关（Gateway）是计算机网络中的一种设备或软件，它用于连接两个或多个不同网络，以便它们可以相互通信。网关在网络通信中充当中转站，将数据从一个网络传递到另一个网络，并执行协议转换、数据包过滤和路由等功能。

### 客户端：用户代理

* 用户代理是任何能够代表用户行为的工具。这类工具以浏览器为主，不过他也可能是工程师和Web开发人员调试应用所使用的哪些程序。
  浏览器**总是**首先发起请求的那个实体，永远不会是服务端（不过，后来已经加入了一些机制，能够模拟出由服务端发起的消息）。
  为了展现一个网页，浏览器需要发送最初的请求获取描述这个页面的HTML文档。
  然后解析文档，并发送数个请求，响应的获取可执行脚本、展示用的布局信息（CSS）以及其他页面内的资源（一般是图片和视频）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，即web页面。之后的阶段，浏览器中执行的脚本可以获取更多的资源，同时浏览器相应的更新网页。


  一个 Web 页面是一个超文本文档。这意味着有一部分展示的内容会是链接——可以被激活（通常是点击鼠标）来获取一个新的网页——用户可以通过这些链接指示用户代理并进行网络浏览。浏览器会将收到的指示转换成 HTTP 请求，并进一步解析 HTTP 响应，向用户提供清楚的回复。

### web服务端

* 在上述通信过程的另一侧是服务端，它*负责提供*客户端所请求的文档。一个服务端可以假装表现为仅有一台机器，但实际上，它可以是共享负载的一组服务器集群（负载均衡）或是其他类型的软件（如缓存、数据库服务、电商服务等），按需完整或部分地生成文档。
  一个服务器可以不仅仅只有一台机器，而多个服务端软件实例也可部署在同一台机器上。利用 HTTP/1.1 和 host标头，它们甚至可以共用同一个 IP 地址。
  （host请求头指明了请求将要发送到的服务器主机号和端口号）

### 代理

在浏览器和服务器之间，有许多计算机和设备参与传递了 HTTP 消息。依靠 Web 技术栈的层次化的结构，传递过程中的多数操作都位于传输层、网络层或物理层，它们对于 HTTP 应用层而言就是透明的，并默默地对网络性能产生着重要影响。还有一部分实体在应用层参与消息传递，一般被称为**代理**（Proxy）。代理可以是透明的，即转发它们收到的请求并不做任何修改，也可以表现得不透明，将它传递给服务端之前使用一些手段修改这个请求。代理可以发挥很多种作用：

- 缓存（可以是公开的也可以是私有的，如浏览器的缓存）
- 过滤（如反病毒扫描、家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（控制对不同资源的访问）
- 日志（使得代理可以存储历史信息）

## HTTP的基本性质

### HTTP是简约的

### HTTP是可扩展的

* HTTP中引入的HTTP标头（header）让协议扩展变得更加容易。

### HTTP无状态，但并非无会话

### HTTP和网络链接

* 在客户端与服务端能够传递请求、响应之前，这两者间必须建立一个 TCP 链接，这个过程需要多次往返交互。

（以上内容需要进一步理解，在学习的过程中无法理解提到的众多概念）

### HTTP流

* 当客户端想要和服务端信息交互的时候，过程分为以下几步：
  1.打开一个TCP链接

  2.发送一个HTTP报文
  3.读取服务端返回的报文信息
  4.关闭连接或者为后续请求重用连接。

### HTTP报文

* HTTP/1.1 以及更早的 HTTP 协议报文都是语义可读的。在 HTTP/2 中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文标头的压缩以及多路复用。即使只有原始 HTTP 报文的一部分以 HTTP/2 发送出来，每条报文的语义依旧不变，客户端会重组原始 HTTP/1.1 请求。因此用 HTTP/1.1 格式来理解 HTTP/2 报文仍旧有效。

  有两种 HTTP 报文的类型，**请求**与**响应**，每种都有其特定的格式。

  * 请求
    ![一个基础的 HTTP 请求](https://raw.githubusercontent.com/just-createone/images/master/http_request.png)

  请求由以下元素组成：
  1.一个HTTP方法，通常是由一个动词，像GET、POST等，或者一个名词，像OPTIONS、HEAD等，来定义客户端执行的动作。典型场景有：客户意图抓取某个资源（使用GET）；发送**HTML表单**的参数值（使用POST）；以及其他情况下需要的那些操作。

  2.要获取的那个资源的路径——去除了当前上下文中显而易见的信息之后的 URL，比如说，它不包括**协议**（`http://`）、**域名**（这里的域名是`developer.mozilla.org`），或是 TCP 的**端口**（这里的端口是 `80`）。

  3.HTTP协议版本号。

  4.为服务端表达其他信息的可选标头。

  5.请求体（body），类似于响应中的请求体，一些像 POST 这样的方法，请求体内包含需要了发送的资源。

  * 响应

  HTTP响应的一个例子：
  ![HTTP 响应的图片](https://raw.githubusercontent.com/just-createone/images/master/http_response.png)

  响应报文包含了下面的元素：
  1.HTTP协议版本号

  2.一个状态码

  3.一个状态信息，这个信息是一个不权威、简短的状态码描述

  4.HTTP标头

  5.可选项，一个包含了被获取资源的主体。

### 基于HTTP的API

（这部分内容没看懂，需要更多的基础知识。。）



# 总结

* HTTP 是一种简单、易用、具有可扩展性的协议，其客户端—服务器模式的结构，加上能够增加标头的能力，使得 HTTP 随 Web 中不断扩展的能力一起发展。

​	   虽然增加了一些复杂度——为了提高性能，HTTP/2 将 HTTP 报文嵌入到帧中——但是报文的基本结构自 		  	   HTTP/1.0 起仍保持不变。

